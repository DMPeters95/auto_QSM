#!/bin/bash

me=`readlink $0`
if [ "x${me}" == "x" ]
then
        me=$0
fi
curdir=`dirname ${me}`

source ${curdir}/utils_check_received
fix_half_series=1
fix_non_gre=1
fix_dones=1
fix_dups=1

log Starting ${me}

# Working Loop
i=0
while [ 1 ]
do
	remove_nongre ${folder_pool}
	remove_halfs ${folder_pool}
	remove_dups_and_dones ${folder_pool}

	get_completed_folder_list folder_list ${folder_pool}
	
	for each_folder in $folder_list
	do
		get_folder_info fldr ${each_folder} || continue
        	get_dicom_info dicom ${fldr_file_dicom}

		log "New folder found: $(basename ${each_folder})"

		# Save condition flag 1 (working) to condition file
		echo "1" | cat > ${file_condition_QSM}

		# Check if the recon would be blocked (by auto backup)
		if [ -e ${file_block_QSM} ] && [ $(cat ${file_block_QSM}) -eq 1 ]
		then
			log "QSM recon blocked by auto backup function"
			break
		fi

		# ============ Receiving done ============ #
		log "Receiving done!!"

		# Remove info file
		# rm ${folder_pool}/${each_folder}/${file_name_info} 
		rm ${each_folder}/${file_name_info} 


		# ================ Run MEDI ================ #
		get_work_folder work_folder fldr dicom	
		echo Creating $work_folder		
		mkdir -p ${work_folder}/DICOM

		# Fix bug with "Argument list too long"
		# find ${folder_pool}/${each_folder}/ -type f -name '*' -exec mv {} ${work_folder}/DICOM/ \;
		find ${each_folder}/ -type f -name '*' -exec mv {} ${work_folder}/DICOM/ \;
		# Clean up
		# rm -r ${each_folder}			
		mkdir -p ${folder_pool}/../cleanup
		mv ${each_folder} ${folder_pool}/../cleanup/

		olddir=${curdir}
		cd ${work_folder}
			

		# QSM recon begin
		echo "Peer             = " ${fldr_AET_peer}
		echo "StudyInstanceUID = " ${dicom_study_instance_uid}
		echo "Exam Number      = " ${dicom_exam_no}			
		echo "Series Number    = " ${dicom_series_no}						


		# Run reconstruction script which takes input of DICOM/ and store output in SWI/ or QSM/)
		${RECON} ${fldr_brand_MF} DICOM

		# Send QSM back
		# Get command for pushing
		# ${COMMAND_PUSH} ${fldr_AET_peer} ${work_folder}/SWI/*
		${COMMAND_PUSH} ${fldr_AET_peer} ${work_folder}/SWI/* ${work_folder}/QSM/*

		cd ${olddir}



		# Log
		space=`df -kh | sed '/ /! {N; s/\n//;}' | awk '$1=="'${disk_data}'" {print $4}'`
		if [ ${fldr_brand_MF} == "SIEMENS" ]
		then
			log "QSM done for: peer ${fldr_AET_peer} uid ${dicom_study_instance_uid} series ${dicom_series_no}"
			echo "[${fldr_AET_peer}] uid ${dicom_study_instance_uid} series ${dicom_series_no} ${fldr_time_stamp}" | cat >> ${file_log_QSM}
			echo -e "uid ${dicom_study_instance_uid} \nSeries number ${dicom_series_no}\nSpace left ${space}" | mail -s "New QSM from ${fldr_AET_peer}" ${email_notice}
		else
			log "QSM done for: peer ${fldr_AET_peer} exam ${dicom_exam_no} series ${dicom_series_no}"
			echo "[${fldr_AET_peer}] exam ${dicom_exam_no} series ${dicom_series_no} ${fldr_time_stamp}" | cat >> ${file_log_QSM}
			echo -e "Exam number ${dicom_exam_no} \nSeries number ${dicom_series_no}\nSpace left ${space}" | mail -s "New QSM from ${fldr_AET_peer}" ${email_notice}
		fi
			
	done

	# Save condition flag 0 (idle) to condition file
	echo "0" | cat > ${file_condition_QSM}		

	if [ "x" = "x${folder_list}" ]
	then
		#echo "Empty folder list. Sleeping"
		sleep ${period_recon}
		i=$[$i + 1]
		if [ $i -ge ${period_recon} ]
		then
			log "Idle"
			i=0
		fi
	else
		i=0
	fi

done
